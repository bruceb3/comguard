#!/usr/bin/env ruby
#
# Using ruby for this script.
# --------------------------
#
# To reduce the likelihood of having trouble running this script, only
# standard features of older versions of ruby will be used.
#
# From the commit-msg.sample;
# --------------------------
#
#> An example hook script to check the commit log message.
#> Called by "git commit" with one argument, the name of the file
#> that has the commit message.  The hook should exit with non-zero
#> status after issuing an appropriate message if it wants to stop the
#> commit.  The hook is allowed to edit the commit message file.
#

# TODO:
#
# * fail if the first line is more than 52-ish characters long.
#
# * Format the body and footer comments to be 72 columns in width.
#  - need to leave existing indentation intact.
#
# * Make sure that there is only two blank lines in the commit messages.
#
# * Remove trailing blanks lines.

$failed = false

commit_log_messages = ARGV[0] or abort "missing commit log message filename"

commit_log = File.readlines(commit_log_messages).map(&:chomp)

# check for upper case characters.
if commit_log[0].match(/[A-Z]/)
  puts "first-line: no upper case characters"
  commit_log[0].downcase!
end

# Valid types are;
#   feat -> feature
#   fix -> bug fix
#   docs -> documentation
#   style -> formatting
#   ref -> refactoring code
#   test -> adding missing tests
#   chore -> maintenance

valid_types = %w( feat fix docs style ref rest chore )
if matches = commit_log[0].match(/^(?<type>\w+)\((?<scope>[\w-]+)\): (?<message>.*)/)
  if not valid_types.include?(matches[:type])
    abort "invalid commit type"
  end
else
  abort "invalid first line"
end

# Need to write changes to the commit messages for git to use.
File.open(commit_log_messages, 'w+') do |fh|
  commit_log.each { |line| fh.puts line }
end

exit $failed ? 1 : 0
